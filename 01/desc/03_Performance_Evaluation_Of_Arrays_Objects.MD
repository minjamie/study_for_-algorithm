#### 빅오 시점에서 배열과 오브젝트가 어떻게 동작하는지와 배열과 오브젝트 내장된 메소드와 루프들이 얼마나 성능이 좋은지에 대해 배워보자

- 다양한 연산들과 배열에 데이터를 입력하는데 빠른 방법이 있고 느린 방법에 대해
	- 배열 앞에 데이터를 추가하는 것이 성능이 나쁜 이유
- 배열을 처리하는 시간 비교
	- For each나 object.key, object.hasownproperty 이런 것

## 1. 객체
- 빅오와 성능 보는 관점에 대해

### 객체는 언제 쓰는가?
![](https://velog.velcdn.com/images/minj9_6/post/7e0b94f3-cb5f-4be1-846b-b4315864c7ee/image.png)
>-  객체는 정렬되어 있을 필요가 없을떄 잘 작동
- 정렬되어있진 않지만 빠른 접근, 입력과 제거를 원할때
	- 입력, 제거, 접근하는 시간이 상수 시간임을 의미
    
```js
let instructor ={
    firstName:'Minjae',
    isInstructor:true,
    favoriteNums:[1,2,3,4]
},
```
> - 자바스크립트가 어떤 정보를 객체 안에 상수 시간안에 저장할 수 있고 원하는 내용을 상수 시간안에 불러올 수 있다.
 	- 따라서 입력과 제거는 
- 단지 key를 사용해서 추가하고 접근하고 삭제하기에 입력, 제거, 접근까지도 모두 상수 시간 O(1)
 
>- 그러나 탐색은 선형시간이 걸리는데 O(N), 여기서 말하는 탐색은 key를 찾는것이 아닌 해당하는 값을 찾는 게 아닌 어떤 특정한 정보가 어떤 값에 있는지 확인하는 것을 의미
	- 예를 들어true 값이 이 객체에서 어디에 저장되어 있는지 알기 위해서 먼저, firstName을 확인하고 값이 무엇인지 보면 Minjae 것을 알 수 있고 isInstructor의 값을 확인하여 true를 찾아내는데 잠재적으로느 이 안에 속성들이 많을 수록 N이 늘어나고 그만큼 걸리는 시간도 늘어나는게 특징

![](https://velog.velcdn.com/images/minj9_6/post/209bb5e6-2e58-4a3c-bede-2c69c7424693/image.png)
- 객체들과 따라오는 메소드 key, values, entries들은 연산량과 컴파일 하는데 걸리는 시간도 있어 모두 O(N) 선형 시간을 가지고
-  hasOwnProperty 메소드는 firstName이라는 속성을 전달하면, firstName이라는 속성이 있는지 없는지 불리언으로 알려주는데 이것은 상수 시간을 갖는다.
	- 왜냐면 firstName 키가 있고 그 값을 원하면 상수 시간으로 이 정보를 접근 할 수 있기 때문

##### 정리
>- 객체는 key value가 모두 있고 모든 연산, 입력, 접근, 업데이트, 제거는 모두 상수 시간이며 탐색은 희귀하지만, 선형시간을 지닌다


## 2. 배열
- 배열을 빅오 통해서 판단해보고 객체와 비교했을때 성능이 어떤지 

#### 배열은 언제 쓰는가?
![](https://velog.velcdn.com/images/minj9_6/post/e07ce525-e870-4890-b625-d3ef62da1f76/image.png)

>- 배열에 가장 중요한 점은 정렬이 되어 있다는 것, 데이터가 정렬되어 있는 기준이 존재로 한 뭉치로 있는 객체와는 다르다
- 정렬되어 있는 것이 필요하다면 유용하지만, 연산을 하는 시간이 더 걸릴 수 있다


![](https://velog.velcdn.com/images/minj9_6/post/4fc11992-3314-43bb-b415-07e431cb1d75/image.png)

- 정렬되어 있는 데이터가 필요할때 배열을 사용할 수 있지만, 성능을 희생할 때 특히 입력과 제거를 할때 더욱 그러하다
- 배열에 있는 데이터를 접근하는 것은 매우 빠르며 접근은 O(1)으로 상수 시간을 지닌다.

```js
let names = ['a', 'b', 'c ']

names.push('d')
```


>- 입력과 제거의 경우 어디에 입력을 제거를 하는지에 달려있습니다.
 - 입력은 정렬되어있는것과 관련되어있는데 만약 배열에 'd' 끝에다가 추가한다면, 배열에 push를 통해 추가하고 인덱스를 주면 객체에 추가하는것과 다를 것 없기에 O(1)으로 상수 시간 지님
 - 문제가 되는 건 배열 앞에 추가할 때인데 인덱스들 때문인데 여기에 배열에 'd' 라는 이름을 추가하려고 하면, 배열에있는 엘리먼트마다 인덱스를 새로 배정해야하기에 배열 앞에 추가를 한다면 O(N) 선형 시간을 지닌다.

![](https://velog.velcdn.com/images/minj9_6/post/1b57d423-5ea6-40a4-8ccd-48c8b1186577/image.png)
>- push와 pop 작업은 상수 시간
- 반면 Shift와 unshift는 전부다 인덱스를 다시 정해줘야 하기에 O(N), 선형 시간
- concat, slice와 splice는 전부 O(N) 선형 시간
- Sort 메소드는 O(N*log N)으로 가장 느림
- 그리고 map, filter, reduce, for each같은 메소드들 모두 O(N)으로 엘리먼트마다 한가지 작업을 실행하고, 갯수를 기록하고, boolean으로 확인하고, 출력을 할 수도 있고, 어떤 작업이든 요소마다 한 작업을 실행해하기에 배열이 커질수록 걸리는 시간도 늘어남

#### 정리
>- 배열은 접근은 어디에 있든 빠르며 O(1)이고 입력과 제거는 어디에 하는지에 따라 달라지며 배열 시작에 이 입력과 제거를 하는것이 끝에 하는것보다 항상 더 느리고 탐색하는 작업은 가장 빨라도 O(N) 선형 시간을 지닌다
=> 어쨌든  배열을 정렬하는 것은 O(N)보다 더 크다.

